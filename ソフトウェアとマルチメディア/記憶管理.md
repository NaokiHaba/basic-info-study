## 確認問題1

仮想記憶方式における補助記憶の機能はどれか。

ア. 主記憶からページアウトされたページを格納する
イ. 主記憶が更新された際に、更新前の内容を保存する
ウ. 主記憶と連続した仮想アドレスを割り当てて、主記憶を拡張する
エ. 主記憶のバックアップとして、主記憶の内容を格納する

### 解答

ア. 主記憶からページアウトされたページを格納する

イ. 主記憶が更新された際に、更新前の内容を保存する
=> 更新前の内容は保存しない

ウ. 主記憶と連続した仮想アドレスを割り当てて、主記憶を拡張する
=> 連続した仮想アドレスは割り当てない

エ. 主記憶のバックアップとして、主記憶の内容を格納する
=> バックアップではなく退避が正しい

## 確認問題2

ページング方式の仮想記憶において、ページ置換えの発生頻度が高くなり、システムの処理能力が急激に低下することがある。このような現象を何と呼ぶか。

ア. スラッシング
イ. スワップアウト
ウ. フラグメンテーション
エ. ページフォールト

### 解答

ア. スラッシング

イ. スワップアウト
=> 物理メモリの容量をあけるために当面の間必要無い内容をハードディスクに書き出すこと

ウ. フラグメンテーション(断片化)
=> コンピュータ上のメモリの管理上の一単位が、そのままでは有効利用できない状態になること

エ. ページフォールト
=> ページング方式の仮想記憶(仮想メモリ)において、プログラム(プロセス)がアクセスしようとした仮想メモリ領域(ページ)が物理メモリ上に無く、ハードディスクなどに退避されていることが分かったときに発生する例外あるいは割り込み

## 確認問題3

図のメモリマップで，セグメント2が解放されたとき，セグメントを移動(動的再配置)し，分散する空き領域を集めて一つの連続領域にしたい。1回のメモリアクセスは4バイト単位で行い，読取り，書込みがそれぞれ30ナノ秒とすると，動的再配置をするのに必要なメモリアクセス時間は合計何ミリ秒か。ここで，1kバイトは1,000バイトとし，動的再配置に要する時間以外のオーバーヘッドは考慮しないものとする。

| セグメント1 | セグメント2 | セグメント3 | 空き |
|------------|------------|------------|------|
| 500kバイト | 100kバイト | 800kバイト | 800kバイト |



### 解答

| セグメント1  | セグメント3 | 空き |
|------------|------------|------|
| 500kバイト | 800kバイト | 900kバイト |

移動するデータ量：

- セグメント3のサイズ = 800kバイト = 800 * 1000バイト = 800,000バイト

メモリアクセス回数：

- 800,000バイト / 4バイト = 200,000回

メモリアクセス時間：

- 読み取り：200,000回 * 30ナノ秒 = 6,000,000ナノ秒 = 6ミリ秒
- 書込み：200,000回 * 30ナノ秒 = 6,000,000ナノ秒 = 6ミリ秒

合計：6ミリ秒 + 6ミリ秒 = 12ミリ秒

## 確認問題4

仮想記憶方式のコンピュータにおいて、実記憶に割り当てられるページ数は3とし、追い出すページを選ぶアルゴリズムは、FIFOと LRUの二つを考える。あるタスクのページのアクセス順序が1,3,2,1,4,5,2,3,4,5のとき、ページを置き換える回数の組み合わせとして適 切なものはどれか。

### 解答


1. FIFOアルゴリズム（First In First Out）： 古くからあるページを入れ替える方式

1: [1]
3: [3, 1]
2: [2, 3, 1]
1: [2, 3, 1]
4: [4, 2, 3] => 1
5: [5, 4, 2] => 3
2: [5, 4, 2]
3: [3, 5, 4] => 2
4: [3, 5, 4]
5: [3, 5, 4]

= 3

2. LRUアルゴリズム（Least Recently Used）： 長い時間参照されていないページを入れ替える方式

1: [1]
3: [3, 1]
2: [2, 3, 1]
1: [1, 2, 3]
4: [4, 1, 2] => 3
5: [5, 4, 1] => 2
2: [2, 5, 4] => 1
3: [3, 2, 5] => 4
4: [4, 3, 2] => 5
5: [5, 4, 3] => 2

= 6

## 確認問題5

メモリリークの説明として，適切なものはどれか。

ア. OSやアプリケーションのバグなどが原因で，動作中に確保した主記憶が解放されないことであり，これが発生すると主記憶中の利用可能な部分が減少する。
イ. アプリケーションの同時実行数を増やした場合に，主記憶容量が不足し，処理時間のほとんどがページングに費やされ，スループットの極端な低下を招くことである。
ウ. 実行時のプログラム領域の大きさに制限があるときに，必要になったモジュールを主記憶に取り込む手法である。
エ. 主記憶で利用可能な空き領域の総量は足りているのに，主記憶中に不連続で散在しているので，大きなプログラムをロードする領域が確保できないことである。

### 解答

ア. OSやアプリケーションのバグなどが原因で，動作中に確保した主記憶が解放されないことであり，これが発生すると主記憶中の利用可能な部分が減少する。

イ. アプリケーションの同時実行数を増やした場合に，主記憶容量が不足し，処理時間のほとんどがページングに費やされ，スループットの極端な低下を招くことである。
=> スラッシング

ウ. 実行時のプログラム領域の大きさに制限があるときに，必要になったモジュールを主記憶に取り込む手法である。
=> オーバーレイ方式

エ. 主記憶で利用可能な空き領域の総量は足りているのに，主記憶中に不連続で散在しているので，大きなプログラムをロードする領域が確保できないことである。
=> フラグメンテーション
